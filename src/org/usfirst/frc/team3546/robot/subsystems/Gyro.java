package org.usfirst.frc.team3546.robot.subsystems;

/**
 * Created by User on 2/3/2017.
 */
import edu.wpi.first.wpilibj.*;
//import org.usfirst.frc3546.Robot;
//import org.usfirst.frc3546.RobotMap;
//import org.usfirst.frc3546.commands.*;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.command.Subsystem;

import java.sql.Driver;


/**
 *
 */
public class Gyro extends Subsystem {

    private AHRS gyro_board;

    private float initial_offset = 0;

    public static final boolean AUTO_CORRECT_GYRO_BASED_ON_INIT_COMPASS = false;
    public static final float LEVEL_TOLERANCE = 7; //Degrees
    public static final double JERK_TIMEOUT = 0.75;

    //Used to check jerk
    private double last_world_linear_accel_x;
    private double last_world_linear_accel_y;
    private double last_check_time;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public Gyro (){
        try {
            /* Communicate w/navX MXP via the MXP SPI Bus.                                     */
            /* Alternatively:  I2C.Port.kMXP, SerialPort.Port.kMXP or SerialPort.Port.kUSB     */
            /* See http://navx-mxp.kauailabs.com/guidance/selecting-an-interface/ for details. */
            gyro_board = new AHRS(SPI.Port.kMXP);

            last_world_linear_accel_x = gyro_board.getWorldLinearAccelX();
            last_world_linear_accel_y = gyro_board.getWorldLinearAccelY();
            last_check_time = Timer.getFPGATimestamp();

            initial_offset = gyro_board.getYaw();
        } catch (RuntimeException ex ) {
            DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
        }


    }

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    /**
     * Get the current orientation of the robot relative to it's starting orientation
     * @return An angle from -180 to 180 that represents the angle between the robot's orientation vector and the
     * vector from the center of the field to the midpoint of the opposing alliance wall
     * If not connected to the field, we'll assume that we're on red
     *
     * The compass should be calibrated so that the vector from the center of the field to the midpoint of the blue
     * alliance wall is the zero heading
     */
    @Deprecated
    public float getRobotAngle() {
        //There are a couple options here, they are as follows:
        // - gyro_board.getYaw() (Proccesed gyro data)
        // - gyro_board.getCompassHeading() (Proccessed compass data)
        // - gyro_board.getFusedHeading() (Combined compass and gyro data)

        float board_angle;
        if (gyro_board.isMagneticDisturbance()){
            board_angle = getGyroSensorAngle();
        } else {
            board_angle = getCompassCorrectedForAlliance();
        }

        return board_angle;
    }

    @Deprecated
    public float getCompassCorrectedForAlliance(){
        DriverStation.Alliance alliance = DriverStation.getInstance().getAlliance();

        int compass_offset;
        if (alliance.equals(DriverStation.Alliance.Red)){
            compass_offset = 0;
        } else if (alliance.equals(DriverStation.Alliance.Blue)) {
            compass_offset = 180;
        } else {
            compass_offset = 0;
        }

        float board_angle = gyro_board.getFusedHeading();
        board_angle = (board_angle + compass_offset) % 360;
        if (board_angle > 180){
            //Shift from 0..360 to -180..180 system
            board_angle = board_angle - 360;
        }

        return board_angle;
    }

    public float getGyroSensorAngle(){
//        return gyro_board.getYaw();
        return -(((gyro_board.getYaw() + 180 - initial_offset) % 360) - 180);
    }

    public double getRobotPitch(){
        return gyro_board.getRoll();
    }

    public double getRobotRoll(){
        return gyro_board.getPitch();
    }

    /**
     * Makes a judgement about whether or not the robot is level relative to the field. Probably used to
     * check that we're over a defense
     * @return True if the robot is level relative to the field. False otherwise
     */
    public boolean isLevel(){
        return Math.abs(gyro_board.getPitch()) < LEVEL_TOLERANCE && Math.abs(gyro_board.getRoll()) < LEVEL_TOLERANCE;
    }

    public double getJerk(){
        if (Timer.getFPGATimestamp() - last_check_time > JERK_TIMEOUT) {
            System.out.println("Resetting gyro values because it's been too long");
            last_world_linear_accel_x = gyro_board.getWorldLinearAccelX();
            last_world_linear_accel_y = gyro_board.getWorldLinearAccelY();
        }

        double curr_world_linear_accel_x = gyro_board.getWorldLinearAccelX();
        double currentJerkX = curr_world_linear_accel_x - last_world_linear_accel_x;
        last_world_linear_accel_x = curr_world_linear_accel_x;
        double curr_world_linear_accel_y = gyro_board.getWorldLinearAccelY();
        double currentJerkY = curr_world_linear_accel_y - last_world_linear_accel_y;
        last_world_linear_accel_y = curr_world_linear_accel_y;

        last_check_time = Timer.getFPGATimestamp();
        return Math.sqrt(currentJerkX*currentJerkX + currentJerkY*currentJerkY);

    }

    public void zeroYaw(){
        initial_offset = gyro_board.getYaw();
    }

    public void zeroYawTo180(){
        initial_offset = convertToNegPos180(gyro_board.getYaw() + 180);
    }

    public static float convertToNegPos180(float zeroTo360Angle){
        if (zeroTo360Angle > 180){
            return zeroTo360Angle - 360;
        } else {
            return  zeroTo360Angle;
        }
    }
}